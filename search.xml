<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java GC详解</title>
      <link href="//ad88/"/>
      <url>//ad88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h1><table><tr><td bgcolor=PowderBlue>Garbage Collection：垃圾回收，即及时地把不再使用的对象清除将内存释放出来。</td></tr></table><h2 id="GC的区域在哪里"><a href="#GC的区域在哪里" class="headerlink" title="GC的区域在哪里?"></a>GC的区域在哪里?</h2><p>jvm中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于java堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><h2 id="GC的对象是什么"><a href="#GC的对象是什么" class="headerlink" title="GC的对象是什么?"></a>GC的对象是什么?</h2><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p><ul><li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p>可达性分析（Reachability Analysis）：从<code>GC Roots</code>开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p></li></ul><div class="note info">            <p>在Java语言中，GC Roots包括：<br>虚拟机栈中引用的对象。<br>方法区中类静态属性实体引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI引用的对象。</p>          </div><h2 id="GC的时机是什么"><a href="#GC的时机是什么" class="headerlink" title="GC的时机是什么?"></a>GC的时机是什么?</h2><ul><li><p>程序调用<code>System.gc</code>时可以触发</p></li><li><p>系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</p></li></ul><h2 id="GC做了哪些事"><a href="#GC做了哪些事" class="headerlink" title="GC做了哪些事?"></a>GC做了哪些事?</h2><p>主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。（回收方式即回收算法详见后文）</p><h1 id="GC的常用算法"><a href="#GC的常用算法" class="headerlink" title="GC的常用算法"></a>GC的常用算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><img src="https://i.loli.net/2020/07/12/SMhswDm1J395LPy.png" width="80%"/><p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。</p><h2 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h2><img src="https://i.loli.net/2020/07/12/1erzvN8m6T2kqdy.png" width="80%"/><p>标记-压缩（整理）算法是标记-清除算法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>该算法不会像标记-清除算法那样产生大量的碎片空间。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><img src="https://i.loli.net/2020/07/12/XHRkW5semiS6nZg.png" width="80%"/><p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p><div class="note warning">            <p>Attention<br>这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p>          </div><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>实现简单；不产生内存碎片</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p><h3 id="新生代-Young-分为Eden区，From区与To区。"><a href="#新生代-Young-分为Eden区，From区与To区。" class="headerlink" title="新生代(Young)分为Eden区，From区与To区。"></a>新生代(Young)分为Eden区，From区与To区。</h3><img src="https://i.loli.net/2020/07/12/l8MKDE3nd4Qzc5T.png" width="80%"/><h3 id="当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。"><a href="#当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。" class="headerlink" title="当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。"></a>当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。</h3><img src="https://i.loli.net/2020/07/12/v27HXdU8h1rIRDV.png" width="80%"/><h3 id="这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区。"><a href="#这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区。" class="headerlink" title="这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区。"></a>这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区。</h3><img src="https://i.loli.net/2020/07/12/ifuG9wOVXo2bdpE.png" width="80%"/><h3 id="再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。"><a href="#再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。" class="headerlink" title="再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。"></a>再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。</h3><img src="https://i.loli.net/2020/07/12/8xnrjKmHJhzPva1.png" width="80%"/><h3 id="经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。"><a href="#经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。" class="headerlink" title="经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。"></a>经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。</h3><img src="https://i.loli.net/2020/07/12/KHs91MSp4LqaWvG.png" width="80%"/><h3 id="老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full-GC），也就是全量回收。如果Full-GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full-GC的操作。"><a href="#老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full-GC），也就是全量回收。如果Full-GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full-GC的操作。" class="headerlink" title="老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。"></a>老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。</h3><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。</p><p><a href="https://blog.csdn.net/leo187/article/details/88920036" target="_blank" rel="noopener">GC参数解析</a></p><h2 id="Serial收集器-XX-UseSerialGC"><a href="#Serial收集器-XX-UseSerialGC" class="headerlink" title="Serial收集器 -XX:+UseSerialGC"></a>Serial收集器 -XX:+UseSerialGC</h2><p>串行收集器是最古老，最稳定以及效率高的收集器</p><p>可能会产生较长的停顿，只使用一个线程去回收</p><ul><li>新生代、老年代使用串行回收</li><li>新生代复制算法</li><li>老年代标记-压缩</li></ul><img src="https://i.loli.net/2020/07/12/htrZJkb6f2aWc4V.png" width="80%"/><h2 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h2><h3 id="ParNew-XX-UseParNewGC"><a href="#ParNew-XX-UseParNewGC" class="headerlink" title="ParNew -XX:+UseParNewGC"></a>ParNew -XX:+UseParNewGC</h3><ul><li>新生代并行</li><li>老年代串行</li></ul><p>Serial收集器新生代的并行版本</p><p>在新生代回收时使用复制算法</p><p>多线程，需要多核支持</p><p><code>-XX:ParallelGCThreads</code>:限制线程数量</p><img src="https://i.loli.net/2020/07/12/mO1p43TIVroJdle.png" width="80%"/><h3 id="Parallel收集器-XX-UseParallelGC"><a href="#Parallel收集器-XX-UseParallelGC" class="headerlink" title="Parallel收集器 -XX:+UseParallelGC"></a>Parallel收集器 -XX:+UseParallelGC</h3><p>类似ParNew</p><p>新生代复制算法 </p><p>老年代标记-压缩 </p><p>更加关注吞吐量 </p><ul><li>使用Parallel收集器+ 老年代串行</li><li>使用Parallel收集器+ 老年代并行</li></ul><img src="https://i.loli.net/2020/07/12/cyPXSrkBmnFs2Rw.png" width="80%"/><h3 id="其他GC参数"><a href="#其他GC参数" class="headerlink" title="其他GC参数"></a>其他GC参数</h3><p><code>-XX:MaxGCPauseMills</code></p><ul><li>最大停顿时间，单位毫秒</li><li>GC尽力保证回收时间不超过设定值</li></ul><p><code>-XX:GCTimeRatio</code></p><ul><li>0-100的取值范围</li><li>垃圾收集时间占总时间的比</li><li>默认99，即最大允许1%时间做GC</li></ul><p>这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优</p><h2 id="CMS收集器-XX-UseConcMarkSweepGC"><a href="#CMS收集器-XX-UseConcMarkSweepGC" class="headerlink" title="CMS收集器 -XX:+UseConcMarkSweepGC"></a>CMS收集器 -XX:+UseConcMarkSweepGC</h2><ul><li>Concurrent Mark Sweep 并发标记清除（应用程序线程和GC线程交替执行）</li><li>使用标记-清除算法</li><li>并发阶段会降低吞吐量（停顿时间减少，吞吐量降低）</li><li>老年代收集器（新生代使用ParNew）<br>CMS运行过程比较复杂，着重实现了标记的过程，可分为</li></ul><p>1.初始标记（会产生全局停顿）</p><ul><li>根可以直接关联到的对象</li><li>速度快</li></ul><p>2.并发标记（和用户线程一起） </p><ul><li>主要标记过程，标记全部对象</li></ul><p>3.重新标记 （会产生全局停顿） </p><ul><li>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li></ul><p>4.并发清除（和用户线程一起） </p><ul><li>基于标记结果，直接清理对象</li></ul><img src="https://i.loli.net/2020/07/12/kBn97eZ5KwWhFGu.png" width="80%"/><h3 id="CMS收集器的特点"><a href="#CMS收集器的特点" class="headerlink" title="CMS收集器的特点"></a>CMS收集器的特点</h3><ul><li>尽可能降低停顿</li><li>会影响系统整体吞吐量和性能</li><li>清理不彻底 </li><li>因为和用户线程一起运行，不能在空间快满时再清理（因为也许在并发GC的期间，用户线程又申请了大量内存，导致内存不够） </li><li>一旦<code>concurrent mode failure</code>（内存预留空间不够）产生，将使用串行收集器作为后备。</li></ul><p>CMS的提出是想改善GC的停顿时间，在GC过程中的确做到了减少GC时间，但是同样导致产生大量内存碎片，又需要消耗大量时间去整理碎片，从本质上并没有改善时间。 </p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。</p><h3 id="与CMS收集器相比G1收集器有以下特点："><a href="#与CMS收集器相比G1收集器有以下特点：" class="headerlink" title="与CMS收集器相比G1收集器有以下特点："></a>与CMS收集器相比G1收集器有以下特点：</h3><p>1.空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p><p>2.可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p><p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p><p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1.标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC（从年轻代空间回收内存）。对应GC log:GC pause (young) (inital-mark)</p><p>2.Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p><p>3.Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p><img src="https://i.loli.net/2020/07/12/lyZtCWJU5hi9ET3.png" width="80%"/><p>4.Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>5.Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p><img src="https://i.loli.net/2020/07/12/PrgmSX9Z5F3o2Vz.png" width="80%"/><p>6.复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><h1 id="Last-but-not-least-——-根据GC来优化代码"><a href="#Last-but-not-least-——-根据GC来优化代码" class="headerlink" title="Last but not least —— 根据GC来优化代码"></a>Last but not least —— 根据GC来优化代码</h1><p>根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议： </p><ul><li><p>最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为<code>null</code>.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为<code>null</code>.这样可以加速GC的工作。 </p></li><li><p>尽量少用<code>finalize</code>函数。<code>finalize</code>函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用<code>finalize</code>方式回收资源。 </p></li><li><p>如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起<code>OutOfMemory</code>. </p></li><li><p>注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。 </p></li><li><p>当程序有一定的等待时间，程序员可以手动执行<code>System.gc()</code>，通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> Java GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈基础算法</title>
      <link href="//5ed/"/>
      <url>//5ed/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学算法"><a href="#为什么要学算法" class="headerlink" title="为什么要学算法"></a>为什么要学算法</h1><p>朋友说，我又不做算法工程师，我就写写前端，我学啥算法？</p><ul><li>算法工程师工资高； <del>比前端不知道高到哪里去了</del></li><li>能够非常好地锻炼你的代码思维和逻辑思维；</li><li>面试笔试要考啊。开玩笑，计算机的灵魂怎么可能不考！ <del>面笔试考算法 = 高考考数学</del></li></ul><h2 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h2><table><tr><td bgcolor=PowderBlue>Algorithm：一个计算过程，解决问题的方法。</td></tr></table><p>Niklaus Wirth：“程序 = 数据结构 + 算法”。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>用什么方式来体现算法运行的快慢？</p><table><tr><td bgcolor=PowderBlue>时间复杂度：用来评估算法效率的一个式子。</td></tr></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">'Hello World'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间复杂度：O(1)</span></span><br><span class="line">print(<span class="string">'Hello World'</span>)</span><br><span class="line">print(<span class="string">'Hello Python'</span>)</span><br><span class="line">print(<span class="string">'Hello Java'</span>)</span><br></pre></td></tr></table></figure><p>常见的时间复杂度：<code>O(1)</code> &lt; <code>O(logn)</code> &lt; <code>O(n)</code> &lt; <code>O(nlogn)</code> &lt; <code>O(n^2)</code> &lt; <code>O(n^2logn)</code> &lt; <code>O(n^3)</code></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><table><tr><td bgcolor=PowderBlue>空间复杂度：用来评估算法内存占用大小的一个式子。</td></tr></table><p>空间复杂度和时间复杂度一样：</p><ul><li>算法使用了几个变量<code>O(1)</code>；</li><li>算法使用了长度为n的一维列表<code>O(n)</code>；</li><li>算法使用了m行n列的二维列表<code>O(mn)</code>。</li></ul><p>“空间换时间”    eg：分布式运算</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>调用自身 + 结束条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">        print(x)</span><br><span class="line">        func(x<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(n, a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        hanoi(n<span class="number">-1</span>, a, c, b)</span><br><span class="line">        print(<span class="string">"%s -&gt; %s"</span> % (a,c))</span><br><span class="line">        hanoi(n<span class="number">-1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><p>思路介绍：n个圆盘，从A到C。</p><ul><li>把n-1个圆盘从A移动B（借用C）  -&gt; <code>hanoi(n-1, a, c, b)</code></li><li>把第n个圆盘从A移动到C </li><li>把n-1个圆盘从B移动到C（借用A）</li></ul><p>关于移动次数：h(x)=2*h(n-1)+1   ≈ 2^x</p><h1 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h1><p><code>Python</code>内置列表查找函数:<code>index()</code>。</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li><p>时间复杂度：<code>O(n)</code></p></li><li><p>也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。</p></li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li><p>时间复杂度：<code>O(logn)</code></p></li><li><p>从有序列表的初始候选区<code>li[0:n]</code>开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(li, val)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:    <span class="comment"># 候选区有值</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><ul><li>内置排序函数：<code>sort()</code></li></ul><p>常见列表排序</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>堆排序</li><li>归并排序</li><li>希尔排序</li><li>计数排序</li><li>基数排序</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>时间复杂度：<code>O(n^2)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li [j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        print(li)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>时间复杂度：<code>O(n^2)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        <span class="keyword">if</span> min_loc != i:</span><br><span class="line">            li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        <span class="comment"># print(li)</span></span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>时间复杂度：<code>O(n^2)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; li[j]:</span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>思路<ul><li>取一个元素p（第一个元素），使元素p归位；</li><li>列表被p分成两部分，左边都比p小，右边都比p大；</li><li>递归完成排序。</li></ul></li></ul><p>动手做一做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li, left, right)</span>:</span></span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= tmp:  <span class="comment"># 找比tmp小的数</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:  <span class="comment"># 找比tmp大的数</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]</span><br><span class="line">    li[left] = tmp <span class="comment"># tmp(元素p)归位</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(li, left, right)</span><br><span class="line">        quick_sort(li, left, mid - <span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>时间复杂度：<code>O(nlogn)</code></li></ul><h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p>树是一种数据结构，是一种可以递归定义的数据结构。</p><ul><li>树是由n个节点组成的集合：<ul><li>如果n=0，那这是一棵空树；</li><li>如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。</li></ul></li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>度不超过2的树，即每个节点最多有两个孩子节点（左孩子节点和右孩子节点）。</p><ul><li>满二叉树 &amp; 完全二叉树</li></ul><img src="https://i.loli.net/2020/07/10/kdiJhPK1al7Hge4.jpg" width="80%"/><ul><li>二叉树的存储方式：链式存储方式&amp;顺序存储方式。</li></ul><h3 id="堆和堆的向下调整"><a href="#堆和堆的向下调整" class="headerlink" title="堆和堆的向下调整"></a>堆和堆的向下调整</h3><ul><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大。</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小。</li><li>堆排序——堆的向下调整性质：<ul><li>假设根节点的左右子树都是堆，但根节点不满足堆的性质；</li><li>可以通过一次向下的调整来将其变成一个堆。</li></ul></li></ul><h3 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h3><p>1.建立堆。</p><p>2.得到堆顶元素，为最大元素。</p><p>3.去掉堆顶，将堆的最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。</p><p>4.堆顶元素为第二大元素。</p><p>5.重复步骤3，直到堆变空。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li, low, high)</span>:</span> <span class="comment"># high：堆的最后一个元素的位置 low：堆的根节点位置</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span> <span class="comment"># 左孩子</span></span><br><span class="line">    tmp = li[low] <span class="comment"># 堆顶</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j +<span class="number">1</span>] &gt; li[j]:</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:    <span class="comment"># tmp &gt;= li[j]</span></span><br><span class="line">            li[i] = tmp</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        li[i] = tmp <span class="comment"># 把tmp放到叶子节点上</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    n = len(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range ((n<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 建堆的时候调整的根</span></span><br><span class="line">        sift (li, i, n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 建堆完成</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 指向当前堆的最后一个元素</span></span><br><span class="line">        li[<span class="number">0</span>], li[i] = li[i], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, i<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 出堆完成</span></span><br></pre></td></tr></table></figure><h3 id="堆排序——内置模块"><a href="#堆排序——内置模块" class="headerlink" title="堆排序——内置模块"></a>堆排序——内置模块</h3><p>python内置模块<code>heapq</code></p><p>常用函数</p><ul><li><code>heapify(x)</code></li><li><code>heappush(heap,item)</code></li><li><code>heappop(heap)</code></li></ul><h3 id="topk问题"><a href="#topk问题" class="headerlink" title="topk问题"></a>topk问题</h3><p>现在有n个数，设计算法得到前k大的数。(k &lt; n)</p><p>解决思路：</p><ul><li>排序后切片  <code>O(nlogn)</code></li><li>冒泡排序，插入排序，选择排序  <code>O(kn)</code></li><li>堆排序思路  <code>O(nlogk)</code></li></ul><p>1.取列表前k个元素建立一个小根堆。堆顶就是目前第k大的数；</p><p>2.依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；</p><p>3.遍历列表所有元素后，倒序弹出堆顶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j +<span class="number">1</span>] &lt; li[j]:</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &lt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        li[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(li, k)</span>:</span></span><br><span class="line">    heap = li[<span class="number">0</span>:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range ((k<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift(heap, i, k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 1.建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (k, len(li)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 2.遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (k<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 3.出数</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = list(range(<span class="number">1000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">print(topk(li, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>时间复杂度：<code>O(nlogn)</code></li></ul><p>一次归并：假设现在的列表分两段有序，将其合称为一个有序列表。</p><ul><li>分解：将列表越分越小，直至分成一个元素；</li><li>终止条件：一个元素是有序的；</li><li>合并：将两个有序列表归并，列表越来越大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(li, low, mid, high)</span>:</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    ltmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= mid:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high+<span class="number">1</span>] = ltmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid + <span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)</span><br></pre></td></tr></table></figure><h2 id="小结-快速排序、堆排序、归并排序"><a href="#小结-快速排序、堆排序、归并排序" class="headerlink" title="小结(快速排序、堆排序、归并排序)"></a>小结(快速排序、堆排序、归并排序)</h2><ul><li>三种的时间复杂度都是<code>O(nlogn)</code></li><li>一般情况下，就运行速度而言：快速排序 &lt; 归并排序 &lt; 堆排序</li><li>三种排序算法的缺点：<ul><li>快速排序：极端情况下排序效率低；</li><li>堆排序：在快的排序算法中相对较慢；</li><li>归并排序：需要额外的内存开销。</li></ul></li></ul><img src="https://i.loli.net/2020/07/12/HDKGdJL6mjVhfip.png" width="85%"/><p>什么是稳定的排序：两个相同的元素的相对位置不变。</p><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><ul><li><a href="">浅谈基础算法Ⅱ</a></li><li><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode</a></li><li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《Algorithms 4th edition - Robert Sedgewick / Kevin Wayne》</a></li><li><a href="http://jeffe.cs.illinois.edu/teaching/algorithms/#book" target="_blank" rel="noopener">《Algorithms - Jeff G Erickson》</a></li><li><a href="https://libo.ink">https://libo.ink</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> python </tag>
            
            <tag> 递归 </tag>
            
            <tag> 列表查找 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COC微信小程序开发笔记</title>
      <link href="//c230/"/>
      <url>//c230/</url>
      
        <content type="html"><![CDATA[<h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><h2 id="Ver-1-2-0-测试版"><a href="#Ver-1-2-0-测试版" class="headerlink" title="Ver 1.2.0 测试版"></a>Ver 1.2.0 测试版</h2><ul><li>修复BUG</li><li>UI优化</li><li>TODO：<ul><li>部落招募板<del>因为是小程序个人号所以过不了审，咕咕咕</del></li><li>可能会在很久很久以后增加触底刷新更多，因为现在数据实在太少了。<del>主要是那个bug导致处理起来涉及的代码挺多的，希望微信官方快快修复啊呜</del></li></ul></li></ul><h2 id="Ver-1-1-3-测试版"><a href="#Ver-1-1-3-测试版" class="headerlink" title="Ver 1.1.3 测试版"></a>Ver 1.1.3 测试版</h2><ul><li>根据选择的大本等级和人气/时间进行筛选。</li><li>优化了夜世界大本等级的显示。</li><li><del>提交审核。</del>审核通过啦！</li><li>修复BUG</li><li>一些题外话：从六号开始想着开始做这个项目到今天，断断续续做了五天，查了很多小程序云开发的资料， <del>还跳+快进地看了腾讯云大学的相关课程。</del> 因为对<code>javascript</code>并不是很熟悉所以整个过程不是特别顺利，但最后还是把预想的大致框架搭了出来，后续再慢慢增加功能吧~</li></ul><h2 id="Ver-1-0-0-测试版"><a href="#Ver-1-0-0-测试版" class="headerlink" title="Ver 1.0.0 测试版"></a>Ver 1.0.0 测试版</h2><img src="https://i.loli.net/2020/06/10/A8xzcdHrQlTUbD5.jpg" width="50%"/><ul><li>底部Tabbar切换三个页面：主页，上传，关于。</li><li>主页显示已经通过审核的阵型，可按人气顺序从高到低或按上传时间从近到远排列。</li><li>每复制一次链接会增加1人气。</li><li>上传页面：填写描述、链接、大本等级并上传对应图片进行阵型提交。</li><li>TODO：大本等级筛选。</li></ul><h1 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>微信开发者工具 Stable V1.03.2005140</li><li>配置：基础库 2.11.1</li><li><a href="https://youzan.github.io/vant-weapp/#/intro" target="_blank" rel="noopener">Vant Weapp</a></li><li>腾讯云开发</li></ul><h2 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h2><h3 id="不想写详细过程了，就简单记录一下憨憨报错吧"><a href="#不想写详细过程了，就简单记录一下憨憨报错吧" class="headerlink" title="不想写详细过程了，就简单记录一下憨憨报错吧"></a>不想写详细过程了，就简单记录一下憨憨报错吧</h3><h3 id="ERROR-1"><a href="#ERROR-1" class="headerlink" title="ERROR 1"></a>ERROR 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">errCode: -401002 api parameter error | errMsg: parameter offset of function skip must be provided;</span><br><span class="line">at &quot;pages&#x2F;index&#x2F;index&quot; page lifeCycleMethod onLoad function</span><br><span class="line">Error: errCode: -401002 api parameter error | errMsg: parameter offset of function skip must be provided</span><br></pre></td></tr></table></figure><p>使用<code>.skip</code>出现的报错，网上的解决方法是将基础库调成<code>2.3</code>以上的版本，但是在当前最新版本<code>2.11.1</code>下依然存在改BUG。</p><p>解决方法：</p><h3 id="ERROR-2"><a href="#ERROR-2" class="headerlink" title="ERROR 2"></a>ERROR 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thirdScriptError</span><br><span class="line">_ is not defined;at &quot;pages&#x2F;index&#x2F;index&quot; page lifeCycleMethod onLoad function</span><br><span class="line">ReferenceError: _ is not defined</span><br></pre></td></tr></table></figure><p>使用以下方法来查询数据库，出现了上述报错。</p><p><del>改写成<code>eav: true,</code>解决。</del></p><p>最后发现是少了声明<code>const _ = db.command</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.where(&#123;</span><br><span class="line">  <span class="string">"eav"</span>: _.eq(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">.orderBy(<span class="string">'hot'</span>, <span class="string">'desc'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="ERROR-3"><a href="#ERROR-3" class="headerlink" title="ERROR 3"></a>ERROR 3</h3><p>审核通过后，正式上线测试时出了大问题，数据库的读写权限因为开的仅创建者可读写，所以相当于只有自己能看到自己上传的阵型。</p><p>紧急修改了权限后还发现，下拉刷新的函数里面调用的依然是旧的方法，因为使用流程的原因可能不太会影响到体验，在下一个测试版本进行修复。</p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 云开发 </tag>
            
            <tag> 开发笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记-从零开始</title>
      <link href="//6b49/"/>
      <url>//6b49/</url>
      
        <content type="html"><![CDATA[<div class="note success">            <p>本文可与<a href="https://github.com/IzzyPrime/JavaWorkspace/tree/master/JavaPractice" target="_blank" rel="noopener">Java练习</a>一同食用。</p>          </div><h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li><p>类名要求：</p><ul><li>类名必须以英文字母开头，后接字母，数字和下划线的组合。</li><li>习惯以大写字母开头。</li></ul></li><li><p>要注意遵守命名习惯，好的类命名：</p><ul><li>Hello</li><li>NoteBook</li><li>VRPlayer</li></ul></li><li><p>不好的类命名：</p><ul><li>hello</li><li>Good123</li><li>Note_Book</li><li>_World</li></ul></li><li><p>方法名要求：命名和<code>class</code>一样，但是首字母小写。</p></li><li><p>好的方法命名：</p><ul><li>main</li><li>goodMorning</li><li>playVR</li></ul></li><li><p>不好的方法命名：</p><ul><li>Main</li><li>good123</li><li>good_morning</li><li>_playVR</li></ul></li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h1 id="Part2-面向对象编程"><a href="#Part2-面向对象编程" class="headerlink" title="Part2 面向对象编程"></a>Part2 面向对象编程</h1><h2 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h2><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><ul><li>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用”…”来表示一个字符串。</li><li>字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的。</li><li>字符串比较必须使用<code>equals()</code>方法而不能用<code>==</code>,要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</li><li>String和char[]类型可以互相转换，方法是：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">"Hello"</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>Java的String和char在内存中总是以Unicode编码表示。</p>          </div></li><li>StringBuilder<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">','</span>)</span><br><span class="line">      .append(i);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure></li><li>StringJoiner<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] fields = &#123; <span class="string">"field1"</span>, <span class="string">"field2"</span>, <span class="string">"field3"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">"连接符 "</span>, <span class="string">"开头 "</span>, <span class="string">"结尾"</span>);</span><br><span class="line"><span class="keyword">for</span>(String field : fields) &#123;</span><br><span class="line">sj.add(field);</span><br><span class="line">&#125;</span><br><span class="line">String st = sj.toString();</span><br></pre></td></tr></table></figure></li><li><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">", "</span>, names);</span><br></pre></td></tr></table></figure></li></ul><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><ul><li><table><thead><tr><th align="center">基本类型</th><th align="center">对应的引用类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">java.lang.Boolean</td></tr><tr><td align="center">byte</td><td align="center">java.lang.Byte</td></tr><tr><td align="center">short</td><td align="center">java.lang.Short</td></tr><tr><td align="center">int</td><td align="center">java.lang.Integer</td></tr><tr><td align="center">long</td><td align="center">java.lang.Long</td></tr><tr><td align="center">float</td><td align="center">java.lang.Float</td></tr><tr><td align="center">double</td><td align="center">java.lang.Double</td></tr><tr><td align="center">char</td><td align="center">java.lang.Character</td></tr></tbody></table></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer n = Integer.valueOf(i);</span><br><span class="line"><span class="keyword">int</span> x = n.intValue();</span><br></pre></td></tr></table></figure></li><li>java的编译器还可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型,我们称之为自动装箱（Auto Boxing）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure></li><li><code>Integer</code>类本身还提供了大量方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// "100",表示为10进制</span></span><br><span class="line">System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// "2s",表示为36进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// "64",表示为16进制</span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// "144",表示为8进制</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// "1100100",表示为2进制</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul><li>如果一个<code>class</code>的读写方法符合以下这种命名规范，那么这种<code>class</code>被称为<code>JavaBean</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure></li><li>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</li><li>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>:右键，在弹出的菜单中选择【Source】，【Generate Getters and Setters】，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</li><li>枚举JavaBean属性:要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">"  "</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">"  "</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li>我们用<code>enum</code>来定义枚举类:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较。</li><li>ordinal()：返回定义的常量的顺序，从0开始计数。</li><li>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">"星期一"</span>), TUE(<span class="number">2</span>, <span class="string">"星期二"</span>), WED(<span class="number">3</span>, <span class="string">"星期三"</span>), THU(<span class="number">4</span>, <span class="string">"星期四"</span>), FRI(<span class="number">5</span>, <span class="string">"星期五"</span>), SAT(<span class="number">6</span>, <span class="string">"星期六"</span>), SUN(<span class="number">0</span>, <span class="string">"星期日"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>     <span class="comment">//覆写toString()的目的是在输出时更有可读性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="comment">// 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h3><ul><li><p>从Java 14开始，引入了新的<code>Record</code>类。</p></li><li><p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point2</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;<span class="comment">//只能通过record关键字由编译器实现继承。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Point[x=%s, y=%s]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><ul><li><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。如果我们使用的整数范围超过了<code>long</code>型,就只能用软件来模拟一个大整数:<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure></li><li><p><code>·</code>BigInteger<code>是不变类，并且继承自</code>Number`。</p></li><li><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p></li></ul><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4567"</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure></li><li><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p></li></ul><h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><ul><li><code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br><span class="line"></span><br><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br><span class="line"></span><br><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br><span class="line"></span><br><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br><span class="line"></span><br><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br><span class="line"></span><br><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br><span class="line"></span><br><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br><span class="line"></span><br><span class="line">Math.random(); <span class="comment">// // 范围是[0,1)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><ul><li><code>SecureRandom</code>就是用来创建安全的随机数的,<code>SecureRandom</code>无法指定种子，它使用<code>RNG（random number generator）</code>算法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure></li></ul><h1 id="Part3-TODO"><a href="#Part3-TODO" class="headerlink" title="Part3 TODO"></a>Part3 TODO</h1><h1 id="Part4-反射"><a href="#Part4-反射" class="headerlink" title="Part4 反射"></a>Part4 反射</h1><h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><ul><li><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息。</p></li><li><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息。</p></li><li><p>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p></li><li><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载<code>class</code>。</p></li></ul><h3 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h3><ul><li><p>对任意的一个Object实例，我们都可以通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个<code>public</code>的<code>field</code>（包括父类）；</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个<code>field</code>（不包括父类）；</li><li><code>Field[] getFields()</code>：获取所有<code>public</code>的<code>field</code>（包括父类）；</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有<code>field</code>（不包括父类）。</li></ul></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, Exception </span>&#123;</span><br><span class="line">String name1 = <span class="string">"Xiao Ming"</span>;</span><br><span class="line">        String name2 = <span class="string">"Xiao Hong"</span>;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(name1);</span><br><span class="line"></span><br><span class="line">Class c = p.getClass();</span><br><span class="line">Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line"></span><br><span class="line">f.set(p, name2);</span><br><span class="line">System.out.println(p.getName());<span class="comment">// "Xiao Hong"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><ul><li><p>我们可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）；</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）；</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）；</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）。</li></ul></li><li><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><ul><li>通过<code>Class</code>实例的方法可以获取Method实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</li><li>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</li><li>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</li><li>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</li><li>通过反射调用方法时，仍然遵循多态原则。</li></ul></li></ul><h3 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h3><ul><li><code>Constructor</code>对象封装了构造方法的所有信息；</li><li>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul></li><li>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</li></ul><h3 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h3><ul><li>通过<code>Class</code>对象可以获取继承关系：<ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul></li><li>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>Java标准库提供了动态代理（Dynamic Proxy）功能，允许在运行期动态创建一个接口的实例；</li><li>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"morning"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Good morning, "</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), // 传入<span class="title">ClassLoader</span></span></span><br><span class="line">            new Class[] &#123; Hello.class &#125;, // 传入要实现的接口</span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">"Bob"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Part5-注解"><a href="#Part5-注解" class="headerlink" title="Part5 注解"></a>Part5 注解</h1><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><ul><li>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</li><li>注解的作用：<ul><li>第一类是由编译器使用的注解：<ul><li>@Override：让编译器检查该方法是否正确地实现了覆写；</li><li>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。</li></ul></li><li>第二类是由工具处理<code>.class</code>文件使用的注解；</li><li>第三类是在程序运行期能够读取的注解。</li></ul></li><li>注解可以配置参数，没有指定配置的参数使用默认值；</li><li>如果参数名称是value，且只有一个参数，那么可以省略参数名称。</li></ul><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><ul><li>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>元注解：有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）：<ul><li><code>@Target</code>：使用@Target可以定义Annotation能够被应用于源码的哪些位置：<ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul></li><li><code>@Retention</code>：定义了<code>Annotation</code>的生命周期：<ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul></li><li><code>@Repeatable</code>:可以定义<code>Annotation</code>是否可重复；</li><li><code>@Inherited</code>:定义子类是否可继承父类定义的<code>Annotation</code>。</li></ul></li><li>如何定义Annotion：<ul><li>第一步，用@interface定义注解；</li><li>第二步，添加参数、默认值；</li><li>第三步，用元注解配置注解。</li></ul></li></ul><h3 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h3><h1 id="Part6-泛型"><a href="#Part6-泛型" class="headerlink" title="Part6 泛型"></a>Part6 泛型</h1><h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
            <tag> JDBC </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo双线部署在Coding和Github上</title>
      <link href="//94b5/"/>
      <url>//94b5/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h2><p>总所周知在国内的网络环境下访问Github的速度实在捉急，偶尔还会抽抽风。尽管通过引入JS实现CDN加速，但是因为没有备案所有无法使用阿里云的<a href="https://www.aliyun.com/product/dcdn?spm=5176.12825654.1kquk9v2l.3.3dbd2c4aIRkqbo" target="_blank" rel="noopener">全站加速DCDN</a>服务。</p><p>所以选择将博客部署在Coding上来改善访问速度。</p><p>而Coding在近期将关闭个人代码托管的业务，所以我们需要将代码托管在自己建立的团队下，那么开始吧！<del>さぁ、ゲームを始めましょう</del></p><h2 id="第一步-实名认证"><a href="#第一步-实名认证" class="headerlink" title="第一步 实名认证"></a>第一步 实名认证</h2><p>在团队项目中想让我们的代码部署在静态网站上需要团队所有者进行团队实名认证，认证流程非常简单，只是入口比较难找<del>找客服问了才找到</del></p><p>从右上角自己的头像进入【团队管理】 → 【团队设置】 → 【高级设置】 → 【实名认证】。</p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/2074ed78f84ae4fc04ba9f1bfc126a19.png" width="80%"/><h2 id="第二步-创建项目"><a href="#第二步-创建项目" class="headerlink" title="第二步 创建项目"></a>第二步 创建项目</h2><p>新建一个代码托管项目，是否公开源代码按个人喜好选择即可。即使你不公开源代码网站也是能够正常访问的！</p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/322d110d6b054db4a85a7e8a2a224365.png" width="80%"/><h2 id="第三步-打开持续部署"><a href="#第三步-打开持续部署" class="headerlink" title="第三步 打开持续部署"></a>第三步 打开持续部署</h2><p>在【项目设置】 → 【项目与成员】 → 【功能开关】中，将持续部署的开关打开。</p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/d68413ba9496755bdc9833a73db7914d.png" width="80%"/><p>这样你就能在全部产品栏目中找到持续部署——静态网站这个选项。</p><h2 id="第四步-添加SSH公钥"><a href="#第四步-添加SSH公钥" class="headerlink" title="第四步 添加SSH公钥"></a>第四步 添加SSH公钥</h2><p>因为是在已经完成在Github上的部署之后进行在Coding上的部署，这里默认已经生成了SSH公钥。</p><p><del>生成方式还是写一下吧</del>打开命令行终端输入 <code>ssh-keygen -m PEM -t rsa -b 4096 -C &quot;your.email@example.com&quot;</code> (您的邮箱)，连续点击 Enter 键即可。</p><p>在终端输入 <code>open ~/.ssh</code>，用文本编辑器打开 <code>id_rsa.pub</code>文件（此处是生成公钥的默认名称，如果生成公钥时采用了其他名称，打开相对应的文件即可），复制全部内容。</p><p>登录 CODING ，点击右上角【个人设置】，选择菜单【SSH 公钥】，点击【新增公钥】按钮。</p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/fb2224e0ee1e32223e8f1fafa9822023.png" width="80%"/><p>将复制的内容填写到【公钥内容】一栏，公钥名称按需填写即可。</p><p>最后设定公钥有效期，可选择具体日期或设置永久有效。</p><h2 id="第五步-配置仓库地址，测试能否部署"><a href="#第五步-配置仓库地址，测试能否部署" class="headerlink" title="第五步 配置仓库地址，测试能否部署"></a>第五步 配置仓库地址，测试能否部署</h2><p>打开根目录下的<code>_config.yml</code>文件，将Coding项目的SSH地址填入其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    #github: git@github.com:IzzyPrime&#x2F;IzzyPrime.github.io.git #此处是你的github仓库地址，可以先注释掉进行测试</span><br><span class="line">    coding: git@e.coding.net:izzyprime&#x2F;blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>执行命令 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/0960e94ee84f82b4a40f759b2c6931e6.png" width="80%"/><h2 id="第六步-部署静态网站"><a href="#第六步-部署静态网站" class="headerlink" title="第六步 部署静态网站"></a>第六步 部署静态网站</h2><p>【持续部署】 → 【静态网站】 → 【新建静态网站】，填写好网站名称，触发机制选择自动部署。</p><img src="https://cdn.jsdelivr.net/gh/IzzyPrime/HexoStaticFile@latest/2020/05/28/17d82c5f9db791bf7c5fc3d5e417a9ba.png" width="80%"/><p>保存后点击【立刻部署】，部署完成后点击访问地址查看能否正常访问。</p><p>如果有自己域名，则可以自行配置CNAME解析，这里就不做赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Coding </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly的客制化</title>
      <link href="//97e8/"/>
      <url>//97e8/</url>
      
        <content type="html"><![CDATA[<p>感谢<a href="https://www.antmoe.com/" target="_blank" rel="noopener">小康</a>大佬的帮助下完成了魔改操作，修改鼠标样式及把主页的Banner去掉均可按照小康大佬的<a href="https://www.antmoe.com/posts/a811d614/index.html#%E8%A7%86%E8%A7%89%E4%BD%93%E9%AA%8C" target="_blank" rel="noopener">教程</a>完成。</p><p>另外随机background，Banner、背景及页脚图片一体化可以参考<a href="https://blog.clouder.im/hexo/butterfly_modify/" target="_blank" rel="noopener">云玩家</a>的攻略<del>二运云玩家跑法.jpg</del></p><p>以下则是我自己魔改的过程及笔记。</p><div class="note info">            <p> 注意<br>本文的操作均在完成<a href="https://docs.jerryc.me/#/config/quick-start" target="_blank" rel="noopener">说明书</a>的初步设置后进行。</p>          </div><h2 id="添加Tidio"><a href="#添加Tidio" class="headerlink" title="添加Tidio"></a>添加Tidio</h2><p>前往<a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a>完成注册，获得一段可以添加在自己网站上的<code>JavaScript</code>代码。</p><p>在<code>butterfly.yml</code>文件中的<code>inject:</code>下进行如下更改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="//code.tidio.co/*****************.js"</span> <span class="string">async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更改鼠标样式"><a href="#更改鼠标样式" class="headerlink" title="更改鼠标样式"></a>更改鼠标样式</h2><p>在<code>.\themes\Butterfly\source\css\</code>目录下新建<code>background.css</code>文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>butterfly.yml</code>文件中的<code>inject:</code>下进行如下更改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/background.css"&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="//code.tidio.co/*****************.js"</span> <span class="string">async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使网站的背景一体化"><a href="#使网站的背景一体化" class="headerlink" title="使网站的背景一体化"></a>使网站的背景一体化</h2><p>即使得Banner到网站的主体部分到Footer的背景图片是连贯的。</p><p>在<code>butterfly.yml</code>文件中的<code>inject:</code>下进行如下更改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/background.css"&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="//code.tidio.co/*****************.js"</span> <span class="string">async&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type="text/javascript"&gt;var</span> <span class="string">full_page</span> <span class="string">=</span> <span class="string">document.getElementsByClassName("full_page");if</span> <span class="string">(full_page.length</span> <span class="string">!=</span> <span class="number">0</span><span class="string">)</span> <span class="string">&#123;full_page[0].style.background</span> <span class="string">=</span> <span class="string">"transparent"</span><span class="string">;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>更改<code>.\themes\Butterfly\source\css\_layout\</code>下的<code>footer.styl</code>的background属性。</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#footer</span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">  <span class="attribute">background-attachment</span>: local</span><br></pre></td></tr></table></figure><p><code>rgba(0,0,0)</code>是黑色，最后的0.5是透明度可以按照自己的喜好修改。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>可以在<code>CMD</code>中ping<code>用户名.github.io</code>添加A记录，</p><p>也可直接添加<code>用户名.github.io</code>为CNAME记录。</p><p>最后需要在<code>.\source\</code>文件夹下新建<code>CNAME</code>文件，因为每次<code>hexo</code>push项目的时候都会把<code>CNAME</code>清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libo.ink</span><br></pre></td></tr></table></figure><h2 id="关于主页图片的加载速度"><a href="#关于主页图片的加载速度" class="headerlink" title="关于主页图片的加载速度"></a>关于主页图片的加载速度</h2><p>这里借用了其他大佬搭建好的 <a href="https://img.plushine.cn/" target="_blank" rel="noopener">图床</a> 。<del>因为免费服务器不知道什么时候就不能白嫖了，所以链接随时可能会die</del></p><p>也可自食其力搭建 <a href="https://blog.csdn.net/weixin_43350051/article/details/106272770" target="_blank" rel="noopener">哇！用github+jsDelivr搭建图床真香</a> 。</p><p>2020.7.12更新：<a href="https://sm.ms/" target="_blank" rel="noopener">安利一个巨好用的图床</a></p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//3eeb/"/>
      <url>//3eeb/</url>
      
        <content type="html"><![CDATA[<h2 id="System-out-println-“Hello-World”"><a href="#System-out-println-“Hello-World”" class="headerlink" title="System.out.println(“Hello World”);"></a>System.out.println(“Hello World”);</h2><p>很久很久以前就想自己搭建一个博客，来记录一下自己的生活、学习以及其他的种种<del>主要是写点文艺青年骚骚的随笔</del>。</p><p>可能是因为自己写的前端实在是太难看了，又或是服务器太贵（不是），一直没有像样的成果。</p><p>这几天在网站看Github相关的视频以及文章，发现了Hexo这个宝藏。</p><p>写下这篇文章或是更多地想记录一个它的变化吧。</p><h2 id="Update-2020-05-30"><a href="#Update-2020-05-30" class="headerlink" title="Update 2020.05.30"></a>Update 2020.05.30</h2><ul><li>使用abbrlink生成永久的文章短链接。</li></ul><h2 id="Update-2020-05-28"><a href="#Update-2020-05-28" class="headerlink" title="Update 2020.05.28"></a>Update 2020.05.28</h2><ul><li>将网站双线部署在Github和Coding上，优化了国内的访问速度。</li></ul><h2 id="Update-2020-05-26"><a href="#Update-2020-05-26" class="headerlink" title="Update 2020.05.26"></a>Update 2020.05.26</h2><ul><li>部署了<a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">Valine</a>，一款快速、简洁且高效的无后端评论系统。</li><li>更新友链及自我介绍页面</li><li>更新了一些以前写的随笔</li></ul><h2 id="Update-2020-05-25"><a href="#Update-2020-05-25" class="headerlink" title="Update 2020.05.25"></a>Update 2020.05.25</h2><ul><li>随机背景</li><li>通过引入JS实现CDN加速</li></ul><h2 id="Update-2020-05-24"><a href="#Update-2020-05-24" class="headerlink" title="Update 2020.05.24"></a>Update 2020.05.24</h2><ul><li>部署了<a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a>，一个Live Chat/Chatbot Builder.</li><li>更改了鼠标样式</li><li>绑定了<a href="https://libo.ink">域名libo.ink</a></li><li><del>TODO：背景图片一体化(主页、Page完成了，Post页面未完成)</del></li><li><del>TODO：随机背景</del></li></ul><h2 id="Dated-from-2020-05-20"><a href="#Dated-from-2020-05-20" class="headerlink" title="Dated from 2020.05.20"></a>Dated from 2020.05.20</h2><ul><li>基本完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间、空间与光的平行</title>
      <link href="//ca0a/"/>
      <url>//ca0a/</url>
      
        <content type="html"><![CDATA[<h1 id="时间、空间"><a href="#时间、空间" class="headerlink" title="时间、空间"></a>时间、空间</h1><p>在高中时期就接触到了相对论，给我们上课的老教授说，这一生能接触到相对论的人可能会不少，但是能够真正理解相对论的人真真切切的屈指可数。非常幸运的是我在大学再一次接触到了这个令我神往的课题。</p><p>起初我本想将这两个话题分开来讲，但是反过来一想，这两者本就是不能够轻易将它们分开的，就如霍金的《时间简史》封面上只有时间它的第二章却写着空间和时间。那么我就粗浅地写一写我关于它们的认知。</p><h2 id="关于时间、空间的认知"><a href="#关于时间、空间的认知" class="headerlink" title="关于时间、空间的认知"></a>关于时间、空间的认知</h2><p>时间和空间的本质是什么，我觉得它们只是物质的两个属性面，他们不过是人类为了描述宇宙而定义的两个虚无的概念。我曾看到一句话：时空和物质是一体两面。这至今仍是物理未解之谜，那么我说说我个人的理解。</p><p>在相对论中，时间和空间的坐标没有差别，就如同任何两个空间坐标没有真正的差别一样。在洛伦兹时空下即是对于狭义相对论的背景时空有着两个对称性，所有的时空点、多有的时空方向都是平权的。狭义相对论是四维时空的数学框架，其本质和牛顿的三维绝对空间加一维时间相同.它只是对客观物理时间和空间的理论抽象，仅仅是一种数学合理化的抽象，可以说是一种工具。而爱因斯坦在狭义相对论中的论断“将自然界定律表示成四维时空连续区域里的定律，则采取的形式是逻辑上最满意的。”最终他将三维的空间和一维的时间合并到一起，在笛卡尔坐标基础上，四维时空坐标创立了。而狭义相对论揭示了作为物质存在形式的空间和时间在本质上的统一性。空间和时间不能轻易分开，而是一个统一的整体。</p><p>##　关于空间维度的认识</p><p>作为一群三维生物，我们对于高于自己维度的东西，只有猜想无法证明，但是一提到四维，我突然醒悟过来：维度这个概念其实非常基础：允许某种东西自由变化的范围。也就是说维度可以是任何东西。那么，时间和空间本身不是维度，而是一个可以用维度概念描述的东西。那么针对我们现在所处的世界，我们把它定义成一个三维的空间，我们在这之上建立了一个不可描述的维度：时间维度，那么时间维度究竟是不是第四维，我觉得可以说时间并不是第四维，而是包含时间维度的这个空间我们可以把它看做一个高维（四维）“空间”，在我看来这个维度的空间的存在对于三维空间有着绝对的修改权。因为我们存在的空间是三维空间，所以我们无法想象那种维度高于我们的生物是如何如何的。</p><p>之前一本书中看到一句话，我们不过是一条三维虫子，乍一看我觉得似乎是这样的。但是仔细想想，我们的这个人，和我们的人生轨迹，是不一样的，我们的人生轨迹无法在三维中描述，只能高于这个维度而存在的，那么这便远远复杂于我们自身的存在。</p><p>写到这里，思路逐渐清晰了起来，现实中的高维空间，不过是人脑。想象力的广度和深度远远高于我们自己所处的这个三维世界。</p><p>之前看过《果壳中的宇宙》，对于时间光锥也有一些自己的理解，那么无论如何我们在时间光锥中看到的都是过去的世界，或许我们永远也接触不到高于我们维度的存在。或许我们不过是高维世界的一个实验品，我们处在宇宙的尸体里渐渐冷却。</p><h1 id="光的平行"><a href="#光的平行" class="headerlink" title="光的平行"></a>光的平行</h1><p>关于平行光、光的干涉、光的衍射以及光的波粒二象性在高中的物理选修中都有所学习，对于这些知识都是一些关于应试的学习，现在能够对它们进行一些自己的理解与思考的学习。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>最早学习的便是关于光的一个提问：光到底是粒子还是波。干涉及衍射和偏振的现象表明光是一种波，光电效应和康普顿效应又表明光是一种粒子。于是就有了这样的理论：光的波粒二象性：指光既具有波动特性，又具有粒子特性。大量的理论和实验告诉人们，光在传播的过程中，主要表现为波动性；而光与物质在相互作用时候，却表现出粒子性。</p><h2 id="关于光的实验"><a href="#关于光的实验" class="headerlink" title="关于光的实验"></a>关于光的实验</h2><p>杨氏干涉实验；薄膜关涉实验；牛顿环实验；单缝衍射实验。这四个实验在之前的学习中都进行过详细的了解。</p><p>光的三个性质：干涉、衍射、偏振都是通过大量的实验得以证实，和之前关于时间和空间的认识不同，这些实验都能够真真切切地描述出这个真实存在的东西：光。</p><p>干涉，两束光的干涉，不考虑衍射效应则有五个典型实验：杨氏双缝实验、平行膜干涉实验、劈尖实验、牛顿环实验、迈克耳孙干涉实验。衍射的实验则可以分为两个方向：一束光的子波干涉效应之下的单缝衍射暗纹公式和圆孔衍射瑞利判据；多束光干涉与衍射叠加效应的光栅。关于偏振的马吕斯定理、布儒斯特定理、波片。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>相比关于时间和空间的思考，关于光的思考突然少的可怜。一些实验一些已经被广为认识的理论封住了我们向上的思考，也许这些理论依然能够又更大的提升，但是以我现在的能力却是不能做到。但是关于物理方面的学习我则是抱有极大的兴趣，今后若是能够接触一定会尽自己的能力去触摸这个高深的世界。</p>]]></content>
      
      
      <categories>
          
          <category> informal essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间 </tag>
            
            <tag> 空间 </tag>
            
            <tag> 光 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于空间的最高维度的思考</title>
      <link href="//893/"/>
      <url>//893/</url>
      
        <content type="html"><![CDATA[<p>起初关于维度的想法，是对于我们所处的环境——这个三维空间的延伸，那么把我们所处的整个空间缩成一个点，这个点向前向后无限延伸，这根轴即是时间，这便是四维空间在我脑海中的雏形。再想起一些书中写的关于维度的描述：在二向箔攻击下，降维成二维的太阳系，三维生物在二维的环境下被用二维细致地描述了出来但是无法在二维环境下生存；又有关于我们不过是一只三维虫子的猜想，我们的一切，从出生到死亡，涵盖了时间方面的一切，在四维空间中不过是一条在三维空间中延伸重叠的虫子。<br><br/><br>之前看过一个关于维度的视频，简单地对视频所述进行描述：</p><font face="楷体">1维：一条线，没有问题。<p>2维：一个平面，没有问题。但为了高维度时解释上的方便，作者用另一个方式来说明二维：分离。即：另外分出一条线。</p><p>3维：一个空间，同样很直观，因为我们就是眼睛所见就是3维的空间。但为了高维度时解释方便，作者同样用了另一个方式来诠释：摺起。一个3维空间下摺起的动作能让2维空间的点跳到另一个2维空间的点。(延伸：一个 n 维空间下的摺起动作能让 (n - 1) 维空间的点跳到另一个 (n - 1) 维空间的点，这个观念之后将会被继续使用到。)</p><p>4维：在三维上加上时间感念，我们的眼睛看到的是三维的世界，但如果有一种生物看得一个人由出生到死亡的一生，那麼3维下的时间对它而言就不是时间了，3维的时间对此生物而言相当於是几何上的第四个维度。这个生物会看到一条波动著的4-D长蛇，一条纪录著一个人由出生到死亡的长蛇。</p><p>举个让人比较容易理解的例子。小时候应该很多人在课本每一页的角落画上一个个的人，每个人都只有一点点动作上的小差异，当把书本快速的翻过时，这些小人合起来就像在做动作一样。如果我们把这一页页都拆开，就可以看到这个2D小人的一生了。</p><p>对这个2D的小人而言，第三个维度是时间，而对我们这些3D人而言，这第三个维度只是书本的厚度。这件事情暗示著：对 n 维世界的人而言，第 n + 1个维度是时间，但对於 n + 1 维世界的人而言，第 n + 1 维也只是空间上的一个维度而已。因此，2D小人的时间对我们 (3D世界的人) 来说是厚度 (空间上的一个维度)，我们 (3D世界的人) 所认为的时间，其实在 4D 世界的人眼中只是一个空间上的维度，而 4D 世界的人眼中的时间，也只是 5D 世界的人眼中的一个空间上的维度。</p><p>那么什么是4D呢? 一条线。没错，一条线! 只是这条线上的每个点分别代表了人 (3D世界的人) 一生中的某一个时点及他的所在位置。</p><p>5维：分离。一个人的一生中有无数的选择。我们常说，如果当时我能怎麼样，现在我就可以如何如何了。是的，5维就是把这所有可能的选择给包容进来。因此，从4D的线上分离出无数条线 (选择)，就构成了第5维。</p><p>6维：摺起。类似於3维的概念，6维能让5维空间中的点自由跳跃。因此，如果一个3D世界的人对现在的生活不满意，假使他拥有6维空间的能力，则他能够自由的变成5维空间中任何一个他所满意的位置。</p><p>7维：前面在4维到6维举的例子都是一个人的一生。现在我们把这个概念放大来看，也可以想像成是宇宙的一生：「从大爆炸宇宙诞生，各种可能性下所产生的各种变化，一直到宇宙灭亡为止。」我们把前面这串叙述，看成7维空间的一个点，如果能有两个这种点，我们就能构筑出7维空间了 (again, 又是一条线)。</p><p>问题是：「从大爆炸宇宙诞生，各种可能性下所产生的各种变化，一直到宇宙灭亡为止。」这句话本身就代表无限大了，怎麼会有两个无限大的点呢?</p><p>解释是：如果大爆炸的一开始初始条件不同，那麼就会有不一样的宇宙诞生。因此，第七维的空间可以想成是两个不同初始条件的宇宙连成的一条线。</p><p>8维：应该可以猜得到那两个字是什么了：「分离」。从7维的线上分离出来的线，构成第8维。更精确地说，就是各种不同的初始条件下形成的宇宙所组成的集合。</p><p>9维：摺起。第9维的摺起动作能让第8维空间内的点跳跃。因此到了第9维的空间，我们已经能够自由穿梭在任何一个宇宙的任何一个时点的任何一个3度空间了。</p><p>10维：呼，终于走到这一步了。</p><p>在第10维，我们将所有可能的宇宙中的所有的时间下的所有的3度空间，想像成10维空间下的一个点。</p><p>这个点已经包含了一切了。你还能想像另一个「所有可能的宇宙中的所有的时间下的所有的3度空间」的点吗?<br></font></p><p>作为一群三维生物，我们对于高于自己维度的东西，只有猜想无法证明，但是一提到四维，我突然醒悟过来：<mark>维度这个概念其实非常基础：允许某种东西自由变化的范围。也就是说维度可以是任何东西。</mark>那么，时间和空间本身不是维度，而是一个可以用维度概念描述的东西。那么针对我们现在所处的世界，我们把它定义成一个三维的空间，我们在这之上建立了一个不可描述的维度：时间维度，那么时间维度究竟是不是第四维，我觉得可以说时间并不是第四维，而是包含时间维度的这个空间我们可以把它看做一个高维（四维）“空间”，在我看来这个维度的空间的存在对于三维空间有着绝对的修改权。因为我们存在的空间是三维空间，所以我们无法想象那种维度高于我们的生物是如何如何的。</p><p>在讲到之前说的，我们不过是一条三维虫子，乍一看我觉得似乎是这样的。但是仔细想想，我们的这个人，和我们的人生轨迹，是不一样的，我们的人生轨迹无法在三维中描述，只能高于这个维度而存在的，那么这便远远复杂于我们自身的存在。</p><p>写到这里，思路逐渐清晰了起来，现实中的高维空间，不过是人脑。想象力的广度和深度远远高于我们自己所处的这个三维世界。</p><p>之前看过《果壳中的宇宙》，对于时间光锥也有一些自己的理解，那么无论如何我们在时间光锥中看到的都是过去的世界，或许我们永远也接触不到高于我们维度的存在。或许我们不过是高维世界的一个实验品，我们处在宇宙的尸体里渐渐冷却。</p>]]></content>
      
      
      <categories>
          
          <category> informal essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间 </tag>
            
            <tag> 维度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part.4 挫锐解纷 和光同尘</title>
      <link href="//47f3/"/>
      <url>//47f3/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-4-挫锐解纷-和光同尘"><a href="#Part-4-挫锐解纷-和光同尘" class="headerlink" title="Part.4 挫锐解纷 和光同尘"></a>Part.4 挫锐解纷 和光同尘</h2><h2 id="丨1丨"><a href="#丨1丨" class="headerlink" title="丨1丨"></a>丨1丨</h2><p>  在常人无法忍受的痛苦之后的浴火重生，才能称作涅槃。</p><p>  那样的火焰才能炼就最强大的你。</p><p>  我们没有权利去怪罪世界上的任何一个人，因为没有谁之为你而活，每一个人，都是他自己。</p><p>  也许，命运之手翻云覆雨，所有的所有造就了这一起。</p><p>  只是希望火焰过后，我还是我。</p><p>  谨守本心，不忘初衷。</p><p>  2015年10月12日<br><br/></p><h2 id="丨2丨"><a href="#丨2丨" class="headerlink" title="丨2丨"></a>丨2丨</h2><p>  如风吹尘埃一般的离散，南北西东，不知所踪。</p><p>  时光把青春变成回忆，把梦想变成遗忘，把坚持变成沉重，把曾经笑得温淡的面孔变成放大的黑白相片，都会苍老，都会改变。</p><p>  If you can return to past.</p><p>  这是一段时光，每个少年都将经历的青葱岁月。虽然又是会茫然若失不知所措，但至少在这段青春中，你曾出现，这便是我最好的回忆。</p><p>  昏黄的天，安静的摩天轮，岁月荒芜了它曾拥有的欢笑，徒留斑驳铁锈。</p><p>  “I prepared for everything, except you.”</p><p>  以后的日子还很长。</p><p>  若人的一生只为遇见一些人，那么你们就是我的灵魂所需。</p><p>  10月22日<br><br/></p><h2 id="丨3丨"><a href="#丨3丨" class="headerlink" title="丨3丨"></a>丨3丨</h2><p>  向死而生。<del>其实是当时看的一本书</del></p><p>  人的一生真的及其短暂，像庄颜对罗辑说得那样“我们在未来等你”而又有多少人能够如愿在未来相遇。</p><p>  当一个人真正面临着失去什么时候，他才能够真正醒悟，他才知道自己需要的是什么，他才懂得去珍惜自己身边曾以为微不足道的东西，他才会明白手中的一切有多么珍贵。</p><p>  以前看到书上说，癌症病人是这个世界上活得最明白的人，因为他有足够的时间去思考自己的一生，回味自己的一生，而那些于电光火石之间失去一切的人，失去了全部，包括回忆的资格。</p><p>  像《龙族》中说的那样，我们每个人内心深处都住着一个衰小孩，每个人看似都是坚强的个体，但毋庸置疑你心中的小孩是个易碎品。</p><p>  在最无助的时候，他低声抽噎，在欢笑之时他蜷缩与角落。当阳光穿过罅隙照射于他肩膀之，他仰头，瞳中带光。</p><p>  所以，愿我们在未来相遇。</p><p>  10月25日<br><br/></p><h2 id="丨4丨"><a href="#丨4丨" class="headerlink" title="丨4丨"></a>丨4丨</h2><p>  想到我们与这个世界的联系，微弱，抑或是脆弱的可怜。</p><p>  每天清晨打开窗，迎接来自太阳的第一抹光，有多少人在这个时刻做着相同的事。</p><p>  《天才在左疯子在右》中那个天才少年说人类不过是一群生活在三维世界中的一群四维虫子。他们的一切都在四维中被一眼忘穿，他们的一生不过是四维生物眼中的一瞬。</p><p>  那么，我们与这世界之间真是进水不犯河水呐。</p><p>  这个世界如同一个精密而又复杂的齿轮，但是少了你它依旧毫无障碍地转动着。</p><p>  我们也终于如点点星光汇入时代的洪流之中。</p><p>  那么，那些能记住你的人便是你在世界上唯一的痕迹，而不是你身下沙发上的屁股印。</p><p>  只有回忆才能让时间永恒。<br><br/><br>  我们就这样深深地可入别人的回忆中，不自知，也无需自知。我们就这样消泯于时代中，不得已，迫不得已。</p><p>  十年之后，如今的一切，想必物是人非，甚至记忆中的信物也消泯，被无情地打磨。</p><p>  再回想起自己年少时的点点滴滴是否又会后悔或是不甘。</p><p>  而后，我们重聚于此，愿时光善待所有人。</p><p>  10月26日<br><br/></p><h2 id="丨5丨"><a href="#丨5丨" class="headerlink" title="丨5丨"></a>丨5丨</h2><p>  人会长大三次：</p><p>  第一次，是发现自己不是世界中心的时候；</p><p>  第二次，是发现即使再怎么努力，终究还是有些事令任无能为力的时候；</p><p>  第三次，是在明知道有些事可能会无能为力，但还是尽力争取的时候。<br><br/><br>  第一次，如此地害怕分别，从未如此。</p><p>  从未如此惊恐。</p><p>  想着高中毕业之后真正的各奔东西，可能终其一生也只有几次能够见面。</p><p>  感觉这些年华终将无法释怀。</p><p>  层有人问我，高中毕业，你害怕嘛？</p><p>  当时我肯定…不！</p><p>  但在这个网络发展爆炸的年代，你寻找一个人容易，你丢失一个人更阿基容易，</p><p>  感觉所有的联系都细如薄丝，好似下一秒就要断裂。</p><p>  突然有一种害怕未来的感觉。</p><p>  害怕如沉没于大海间，终不可寻。</p><p>  12月16日<br><br/></p><h2 id="丨6丨"><a href="#丨6丨" class="headerlink" title="丨6丨"></a>丨6丨</h2><p>  有些时候想着自己的过去，现在，未来会有那么一瞬的释怀，然后便是迷茫，好像丢失了所有方向。</p><p>  有些事注定是要铭记一辈子了吧？那些讨厌的人，厌恶的事也是会永永远远丢开的，只是不知能否忘记。</p><p>  而那些能够陪你走一生的朋友，谢谢他们。</p><p>  那些能够陪你走一程的朋友，谢谢老天。</p><p>  再见不是一句告别语，而是一句承诺。</p><p>  谢谢你们来过我的青春，只是可惜我没有能够早点遇见你们。</p><p>  12月7日<br><br/></p><h2 id="丨7丨"><a href="#丨7丨" class="headerlink" title="丨7丨"></a>丨7丨</h2><p>  有些东西总就是要随时间走散的，</p><p>  令时间永恒的，也只有记忆了。</p><p>  为什么很多人的青春都是刻骨铭心的，只是因为在那个年代的你，太过敏感，还未于巨人的冲撞中丢失了自身的棱角。</p><p>  那些时间过得最慢，最清楚。</p><p>  每一个有心的人，都会留在心里，和别人心里。</p><p>  可能真的需要在那些无助的时候，告诉自己一切都好，哪怕天都要塌了。这样，至少还有一种继续前进的力量，在危难之中，不竭。</p><p>  If the world is not as peaceful as usual, please believe there are plentiful fish here.</p><p>  12月22日 冬至<br><br/></p><h2 id="丨8丨"><a href="#丨8丨" class="headerlink" title="丨8丨"></a>丨8丨</h2><p>  新的一年终归是要到来了。</p><p>  在新年伊始之日，人们念念叨叨，过去一年的一切，未来一年的希冀。</p><p>  这，是一个节点吧。</p><p>  这不过是漫长的时间轴中寻常的一点，只是，人们叫它新年的第一天罢了。</p><p>  所以，与我而言，对于所有人来说，每一天都应该这样，不是吗？每一天都应道是新的一年，或是新的一生，不是吗？</p><p>  朝生暮死《天才在左疯子在右》中作者这样做着。他能和这么多常人无法理喻之人相处，能够接收如此多匪夷所思的想法，他不过是做到了朝生暮死。</p><p>  但他做到了。</p><p>  每一日清晨，阳光透过窗棂洒在他床上，他睁开双瞳，这又是新的一天，这又是新的一次生命。</p><p>  过往都存在于脑海之中，任凭提取，放下了。</p><p>  那些与诡异“精神病”的交谈也存储下来，不会再映照到他的生命中，他仍然是他，虽然气场缩小，却未被影响。</p><p>  未必需要做到朝生暮死。</p><p>  但每一天对于我来说都应当是新年。</p><p>  12月30日<br><br/></p><h2 id="丨9丨"><a href="#丨9丨" class="headerlink" title="丨9丨"></a>丨9丨</h2><p>  总有那么几首歌，在耳边回荡之时，会让你想起一个人；</p><p>  总有那么几首歌，在耳畔萦绕之际，会让你想起一些事。</p><p>  那么，总会有那么一个人陪你听完所有的歌，</p><p>  走完所有的路。</p><p>  陪伴是最长情的告白。</p><p>  2016年1月1日<br><br/></p><h2 id="丨10丨"><a href="#丨10丨" class="headerlink" title="丨10丨"></a>丨10丨</h2><p>  2016年1月1日 23:45<br><br/></p><h2 id="写在2020"><a href="#写在2020" class="headerlink" title="写在2020"></a>写在2020</h2><p>  最后一段文字被我删掉了，因为后面还有半年的东西没有整理到电脑上。一时半会可能也不会更新了，就想留着空白。</p><p>  整理曾经的日记的时候发现一开始写日记的时候都是段子 <del>整理到电脑上的时候删了很多很多</del> ，后面逐渐开始写一些看起来很 <del>疼痛</del> 的文字。但其实在回忆中大多的东西都是美好的，未来可能也不再会去写一些类似的文字了，看着自己曾经的文字总觉得内心还是有着光亮的，希望终能得偿所愿~</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h3><p>  可能更多地想写一些学习笔记吧，可能偶尔还是会忍不住写写想写的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part.3 从你的 全世界路过</title>
      <link href="//85a8/"/>
      <url>//85a8/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-3-从你的-全世界路过"><a href="#Part-3-从你的-全世界路过" class="headerlink" title="Part.3 从你的 全世界路过"></a>Part.3 从你的 全世界路过</h2><p>  看过张嘉佳的那本书《从你的全世界路过》，封面上有一句话， I belonged to you.但，终究只是路过呢，错身而过，汇入人海之中。</p><p>  有人和我说，自己想要得到的，尽一切努力去获取。那如果对象是一个有感情的人呢？不属于你的，终究会逝去，而且将融入你身后的黑暗中，无迹可寻。有些感情，终究是虚浮的，就像有人说的那样，她喜欢的，只是喜欢着她的你罢了。</p><p>  而不是你。</p><p>  两个灵魂的撞击并不是那么容易的吧。那么于人海之中又有多么艰难地去找寻一个人，多么漫长的等待。可，你甘心在遇见最好的她之前用尽了最好的自己么？</p><p>  或许，我们依然年轻，说一切都还太早。我们的一天不过是站在氤氲的早餐铺旁跺着脚等待，裹着棉衣站在一大群学生中在升旗广场上等待，在空气沉滞的课堂上望着老师的双眸等待，站在，雪地中，等待着一夜白头。</p><p>  月色虚浮，人影绰绰。</p><p>  与你相遇的春天 就要来了。</p><p>  再也没有你的春天 就要来了。<del>四月是你的谎言太上头了</del></p><p>  2016年1月29日 17:05<br><br/></p><h2 id="丨1丨"><a href="#丨1丨" class="headerlink" title="丨1丨"></a>丨1丨</h2><font face="楷体">  每个人的内心深处都有脆弱和阴暗的一面，<p>  对于拯救生命而言，抢劫财物不值一提。</p><p>  虽然从法律上说，我们不应该为了一个人的善行而赦免其犯下的罪。</p><p>  但是如果判他有罪，将会对整个社会秩序产生极度负面的影响。</p><p>  我宁愿看到下一个抢劫犯拯救一个生命。</p><p>  也不愿看见遵纪守法的无罪者对于他人所受的苦难</p><p>  视而不见。</p><p>  ——布鲁塞判决<br></font></p><p>  2015年3月23日<br><br/></p><h2 id="丨2丨"><a href="#丨2丨" class="headerlink" title="丨2丨"></a>丨2丨</h2><p>  有些时候，觉得人生轻薄如纸，于万卷书中暗自轻伏，在这个巨大的图书馆的一角，任凭自己被放入书架，直至积满灰尘。</p><p>  人生是短暂的，但转念一想，对于这时的我们来说却是无尽的，路漫漫，望不见尽头。</p><p>  人的一生，并非徒劳无功的。</p><p>  3月25日<br><br/></p><h2 id="丨3丨"><a href="#丨3丨" class="headerlink" title="丨3丨"></a>丨3丨</h2><font face="楷体">  在湖边吃饭，跑来一只狗狗坐在岸边。我吃完饭狗狗还在原地。老板来结账时看着狗狗低语，又来了。我问，它是走丢了还是主人不要它了？老板说，它是流浪狗，以前还有只流浪猫。它常和野猫打架抢鱼骨头来给小猫，小猫会翻垃圾找骨头给它。后来小猫出意外死了……我问狗狗，很想它吧？狗狗说，喵。<p>  《再美也美不过想象》<br></font></p><p>  3月28日<br><br/></p><h2 id="丨4丨"><a href="#丨4丨" class="headerlink" title="丨4丨"></a>丨4丨</h2><p>  这是梦开始的地方。</p><p>  一年前，也是在这个地方，躲在一堆书后面，一个叫做默默的女孩在我笔下成形。还有那场三月飞雪。仔细一算，已经是一年了吧。</p><p>  写下这本小记之后，才发觉时光真的实在不知不觉中令人堕入深渊，一晃神，物是人非。</p><p>  明天是愚人节，我喜欢你，我没有说谎。<del>禁止套娃</del></p><p>  这是梦开始的地方，我仍在努力。</p><p>  3月31日<br><br/></p><h2 id="丨5丨"><a href="#丨5丨" class="headerlink" title="丨5丨"></a>丨5丨</h2><p>  我们是一群逆旅者，前路曲折却无法停住脚步，我们不愿岁月流逝却无所事事，并在无所事事中饱经岁月流逝，不经意轮回般怅然若失。</p><p>  4月1日<br><br/></p><h2 id="丨6丨"><a href="#丨6丨" class="headerlink" title="丨6丨"></a>丨6丨</h2><p>  人是一种惰性的生物。</p><p>  无论是多么美好的事物，也只有逝去之后，人们才懂得珍惜。</p><p>  时光对于人来说，更亦是如此，但人们并非因为懂得了珍惜而伸出手来抓住眼前的时光，和时光中的人。他们只是默默地回头，看着已然逝去的时光，凭双眼被泪水沾湿。</p><p>  过去的终究是过去的，若是再放手，你失去的只会更多。</p><p>  过去并非是让你忘记，而是请你放下。</p><p>  4月2日<br><br/></p><h2 id="丨7丨"><a href="#丨7丨" class="headerlink" title="丨7丨"></a>丨7丨</h2><font face="楷体">  “他步上救护车的时候还在微笑，下一刻却不再醒来，他这样突然地离开，我怎可以忘记他？十年后，二十年后，也不可能。我只能忘记他所有的缺点。”<p>  我先笑。“你笑什么？”她问我。“令爱永恒的，竟是别离。”我说。“是的，唯一可以战胜时光的，就是回忆。”<br></font></p><p>  4月15日<br><br/></p><h2 id="丨8丨"><a href="#丨8丨" class="headerlink" title="丨8丨"></a>丨8丨</h2><p>  曾经觉得很遥远的时光，如今却早已甩于身后。</p><p>  再一次想起自己予自己定义的时光的感悟的起点。六年级的时候，坐在妈妈自行车后座上去上围棋课，想到现在近在眼前的时光，经年之后，将被甩于身后多少距离。如今，回头一望，当时的场景历历在目，却是没有了真实发生于自己身上的感受。</p><p>  碎片于天际坠落，曾经的画面重凝于眼前，有些东西能够找回，可它不再是她。</p><p>  5月3日<br><br/></p><h2 id="丨9丨"><a href="#丨9丨" class="headerlink" title="丨9丨"></a>丨9丨</h2><p>  傍晚，夕阳的余晖照映在天边，淡淡的云层掀起一条淡红色的光芒。</p><p>  我歪着头，从讲台，目光够及窗棂，其外斜映着枝丫，天色低沉，黑色的光影映入眼帘，在黑色树形轮廓和空隙之后，是天际。</p><p>   twilight woods.</p><p>  晚霞与我隔着树、窗、和我自己。</p><p>  班中有人注意到了，大家纷纷扭头去看，美景。</p><p>  而低头之人在追寻另一样东西。</p><p>  我与这世界，</p><p>  如隔千里之遥，又如咫尺之近。</p><p>  5月11日<br><br/></p><h2 id="丨10丨"><a href="#丨10丨" class="headerlink" title="丨10丨"></a>丨10丨</h2><p>  今天阳光正好，早上起床之时看着窗外明媚，便觉一日心情渐好。</p><p>  也听说昨天的漫天星斗，只可惜没有去看。其实只是不知晓，也不知此生能有几回能站在这片天空下，静观满天繁星。</p><p>  午间的时光静悄悄地流淌，待一觉醒来，早已是下课，也过了512下午三点半的防空警报。窗外的阳光愈发浓郁起来，教室中也未见多少人，空荡地留下时光，阳光歇映进走廊，阳光下的他们身上散发着光芒。</p><p>  我就这样错身而过，汇入时代的洪流。</p><p>  5月12日<br><br/></p><h2 id="丨11丨"><a href="#丨11丨" class="headerlink" title="丨11丨"></a>丨11丨</h2><p>  有时，塞上耳机，听到那些熟悉的歌曲，总是会想起曾经的点点滴滴。</p><p>  一年前，七月，在五楼朝西的小办公室里，吹着空调听着歌，浪漫却不单调的晚上。</p><p>  两年前，澳洲的大巴上，耳机中徐徐传出音乐，就着阳光。小睡一番，平稳且安宁。</p><p>  这是属于我的回忆。</p><p>  莫名觉得美好的时光的起点就在那时。</p><p>  从车窗望出去，湛蓝如洗的天空，整齐的行道树，对于中国学生完全不同的学习生活，在晚上由home stay的妈妈带着去市中心转一转，看着摩天轮和大钟出神。</p><p>  在悉尼，穿行与异国的城市中，十几天第一次吃到中国菜的狼吞虎咽、</p><p>  那么，这些，觉得已去的时光也没什么值得后悔的了。</p><p>  反正，我们再也回不去了。</p><p>  就这样一路向前。</p><p>  正因为回不去了，所以才值得珍藏。<br><br/></p><p>  我们一路向前。</p><p>  人生若只如初见，应该有无限多的美好。</p><p>  6月2日<br><br/></p><h2 id="丨12丨"><a href="#丨12丨" class="headerlink" title="丨12丨"></a>丨12丨</h2><p>  两年就这样飞驰而过，两年前，我正收拾着前往澳洲的行囊吧。</p><p>  骤然回想，自己在纸上写下一些什么时，总是会想到过去，对于未来的憧憬或是希望很少提及。</p><p>  并非是因为我拘泥过去吧，向前的路上一步三回头。只是，对于未来，我只愿意在内心，自己一个人时，没有纸，没有笔，没有一切时，静静地躺在床上，或是窗棂边的阴影中，在脑海中，凭它慢慢浮现。</p><p>  低头仔细想想，时间仿佛是灰色的，安静，不容置疑，固执，无法触摸……但是，在时间下生活着的我们身上却是有着色彩，明艳，动人。</p><p>  想着多年之后，数十年后，我也将步暮年，以前想到死亡时、老去时总是会莫名地心悸、害怕、或者说是敬畏，未知。</p><p>  那时，回想起从出生慢慢往后推移，总觉得一切都会过得好快吧，曾经看得那么重的东西，也会是释然的吧。</p><p>  一些不属于自己的东西，在最后，终究是要失掉的。</p><p>  一些属于自己的东西，在最后的最后也终将会失去的。</p><p>  不留一丝痕迹。</p><p>  6月22日<br><br/></p><h2 id="丨13丨"><a href="#丨13丨" class="headerlink" title="丨13丨"></a>丨13丨</h2><p>  有些时候，想让自己能够看淡一些东西，想着想着当真是释怀了的，但是，心知肚明，在不久的将来，会像丢失了心爱的玩具一般哭泣。</p><p>  我想当一个守夜人，在最深最深的夜晚，在最黑最黑的夜晚，守护者属于别人最珍贵的东西，以及别人。哪怕对于守夜人来说一文不值。</p><p>  坐在讲台上，微微一抬头便可以看到整个班，每个人，他们心怀梦想。</p><p>  6月22日<br><br/></p><h2 id="丨14丨"><a href="#丨14丨" class="headerlink" title="丨14丨"></a>丨14丨</h2><p>  你脚踩的地狱是天堂的倒影，</p><p>  我唇角的故事终是时间的毁烬。<br><br/></p><p>  高三就这样来了。</p><p>  一步一步往前走，希望总有一天能望见尽头。</p><p>  在如此纷繁的世界里，我们独处于一种别样的宁静之中，我想这种心境下的文字才能是最释然的吧。</p><p>  所以，想在休息之时，在脑海中绘下一本书，于苍茫人海中静静伫立。</p><p>  放下念想，做该做的事，读该读的书，写该写的字，爱该爱的人。好像很缥缈，好似很充实。</p><p>  希望阳光终会于罅隙中探头。</p><p>  7月8日<br><br/></p><h2 id="丨15丨"><a href="#丨15丨" class="headerlink" title="丨15丨"></a>丨15丨</h2><p>  和w进行了亲切的人生交谈，当然，是纸条形式的。</p><p>  “能不能说点有营养的话？”w如是吐槽。</p><p>  哦，好的。小鸡炖蘑菇，椒盐小龙虾，红烧鲫鱼，黑胡椒牛排，意大利通心粉，铁板牛柳，重庆鸡公煲…</p><p>  够营养了吧。<br><br/></p><h2 id="丨16丨"><a href="#丨16丨" class="headerlink" title="丨16丨"></a>丨16丨</h2><p>  每个人的心里面都住着一个衰小孩。</p><p>  如果夏弥真的只是夏弥就好了。</p><p>  在如此一个硕大的世界中，每个人都静默着，每个人都是孤独的，在宇宙中微尘般，孤独着。其实每个人又并非是真正孤独的，只是还未找寻到属于自己的，能够不会再让自己于孤独中沉沦的，彼岸。彼岸花在黑暗中盛放，摇曳，对这个世界张牙舞爪。</p><p>  2015年7月17日</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part.2 珞玉无声 重回涅槃</title>
      <link href="//38be/"/>
      <url>//38be/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-2-珞玉无声-重回涅槃"><a href="#Part-2-珞玉无声-重回涅槃" class="headerlink" title="Part.2 珞玉无声 重回涅槃"></a>Part.2 珞玉无声 重回涅槃</h2><p>  最后一页泛黄的书页从指间滑落。</p><p>  他的故事在此结束，然而我的故事仍然在继续。</p><p>  有些东西我们无论如何也抓不住，我们终将在不可逆流的时光中，逐渐老去，无论身心。</p><p>  我依然记得，书的最后说：<br><font face="楷体"><br>  人生若只如初见，应该有无限多的美好。”我们在单行线上一路向前，前方的道路落满光斑，我们没有从头再来的权利，只能向前，走在未知的道路上。</p><p>  我们平淡的流年，忍不住会阵痛的那些年代，就这样，伴随着每一天的日落天明，越过冗繁的时间线，坠落得悄无声息。然而某一天，某个熟悉的街口，某个和记忆中深藏的事件重合之后，那一刹那间的翻涌，总是会让人心脏深处某个地方，会忍不住心疼的。<br></font><br>  我依稀记得那年苏灿对唐妩说，“但是，请不要让我忘记你，因为你是如此的让人难以忘记，即使我涅槃重生，以毁烬这世界为代价。”我也记得几年后，唐家家宴后，那穿破雨水而来刺目的灯光和随之映入眼帘在雨水冲刷下泛着光芒的黑色宾利车身。</p><p>  而我，愿在最不起眼的角落里，安静地等待着。期待黎明撕破黑暗，铺天盖地地降临。</p><p>  书中曾说，有的东西是可以被改变的，比如人生，宿命之所以会存在，那是因为人生已经丧失了突围的勇气，在巨人的惯性之中，迷失了自身的棱角。</p><p>  又有多少人能够逆流而上，看见黎明悄然降临。</p><p>  生活远比想象的要残酷，愿有一天，在漫长的流年中彼此分离的人们，在下个路口，相见。</p><p>  愿我们能够在斑驳的流年中奔向不朽的永恒。</p><p>  愿，青春无悔。</p><p>  谨以此篇，</p><p>  代序，</p><p>  献给青春中缓步向前的我们。</p><p>  2014年8月8日 23:59<br><br/></p><h2 id="丨1丨"><a href="#丨1丨" class="headerlink" title="丨1丨"></a>丨1丨</h2><p>  时间是良药，同样，时间在你毫无防备之时，划下重重的刻痕。</p><p>  初中三年，高中一年就这样过来了，看到那些三十而立的人写的书，感觉很多东西自己根本就抓不住。</p><p>  还有六百多天，六百多个二十四小时，我不知道两年之后当最后一门考试的结束铃声打响之时，有些我希求抓住的东西还能否抓住，回想起两年来的人人事事是否还会有如今的阵痛之感。</p><p>  我不敢毫无顾忌地去做自己想做的事，因为我不是重生者，我没有先知先觉，我怕我会做错什么，会一失足成千古恨。老妈和我聊天的时候，说到我小时候的点滴，只能叹改变之巨，无法想象。小学凶厉的班主任的六年压抑，虽说我感谢她带给我的直伴初中的超棒数学成绩，以及强大的逻辑思考能力，但亦或是因为她，我学会的思考，让我沉默。</p><p>  以前的我的影子在我的身上渐渐变化，性格的转变，回想起来，心惊肉跳。总觉得自己的性格不好，也不知该如何改变。</p><p>  我只想做回我自己，不愿有所顾忌，可是不可能了。</p><p>  2014年9月5日<br><br/></p><h2 id="丨2丨"><a href="#丨2丨" class="headerlink" title="丨2丨"></a>丨2丨</h2><p>  嗯，我想默默写下这个数字，66。<del>这本来是第六十六个短篇</del></p><p>  六六大顺多好啊，多吉利，大家都喜欢讨个彩头，凑个吉利。可是人生哪有什么一帆风顺的。</p><p>  我的初中没有同学录，只有一张现在已略微泛黄的中考倒计时六十六天和其上的同学签名。</p><p>  我感谢那些曾陪伴我走过一程的兄弟。</p><p>  尽管，已然有人走散，再无回头之路。</p><p>  9月11日<br><br/></p><h2 id="丨3丨"><a href="#丨3丨" class="headerlink" title="丨3丨"></a>丨3丨</h2><p>  你上完厕所一般都用哪只手擦？</p><p>  “唔，右手吧。”</p><p>  哦，我一般都用纸。</p><p>  “你看这是什么？”</p><p>  冷静，冷…静…啊喂！！！</p><p>  9月13日<br><br/></p><h2 id="丨4丨"><a href="#丨4丨" class="headerlink" title="丨4丨"></a>丨4丨</h2><p>  张嘉佳的从你的全世界路过</p><p>  我希望有个如你一般的人。</p><p>  如山间清爽的风，如古城温暖的光。</p><p>  从清晨到夜晚，由山野到书房。</p><p>  只要最后是你，就好。</p><p>  9月14日<br><br/></p><h2 id="丨5丨"><a href="#丨5丨" class="headerlink" title="丨5丨"></a>丨5丨</h2><p>  You come to love,</p><p>  Not by finding the perfect person,</p><p>  But by seeing the imperfect person perfectly.</p><p>  这次，将这句话送给w。</p><p>  好聚好散</p><p>  9月16日<br><br/></p><h2 id="丨6丨"><a href="#丨6丨" class="headerlink" title="丨6丨"></a>丨6丨</h2><p>  In those carefree years, </p><p>  if she only gave you a smile,</p><p>  if he only did something silly for you, </p><p>  it made you feel as if you owned the entire world.</p><p>  9月16日<br><br/></p><h2 id="丨7丨"><a href="#丨7丨" class="headerlink" title="丨7丨"></a>丨7丨</h2><p>  晚读的时候莫名其妙的想起了如果没有你，想起了当初的第一季好声音和那一段时光，轻声哼唱。</p><p>  你，就是那段时光。</p><p>  w说好想念初中的时光。</p><p>  我也是。怀念早上趴在教室的走廊上看着下面集结的人群，耳边放着《我们都是好孩子》然后匆匆地向楼下赶去。怀念晚读的时候傻傻地唱《如果没有你》。</p><p>  结果真的下雨了。</p><p>  9月28日<br><br/></p><h2 id="丨8丨"><a href="#丨8丨" class="headerlink" title="丨8丨"></a>丨8丨</h2><font face="楷体">  大概凌晨两点的时候，我被一阵扑簌簌的声音吵醒,我模糊地看见方茴在沙发上抱成一团,她在微微颤抖,发出动物一样的呜呜声。<p>  我爬起来，坐到她身边拍着她问：“怎么了？做噩梦啦？”</p><p>  “我…梦见他了…”方茴抬起头，满脸绝望地说：“可是…为什么是梦呢？”</p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——《匆匆那年》<br></font></p><p>  年少的那些年的阵痛在回忆中无法抹去，感情的刻痕深埋心底。</p><p>  满脸绝望，为什么是梦呢？</p><p>  想回到曾经，却只是个梦，肝肠寸裂。又有谁能够体会深夜一人独醒的哽咽，和从梦中惊醒的无助，已无法分辨梦与现实初醒时的绝望。</p><p>  我不想在夜深时双目黯淡无光，只是绝望。</p><p>  10月8日 月全食<br><br/></p><h2 id="丨9丨"><a href="#丨9丨" class="headerlink" title="丨9丨"></a>丨9丨</h2><p>  再见，其实不是一句告别，而是一句承诺。</p><p>  年轻时候的我们心中总有一个等不到的人，而那个人却终将成为我们所有温暖的回忆。那是一片只有我们孤独沦陷进去的沼泽。</p><p>  10月19日<br><br/></p><h2 id="丨10丨"><a href="#丨10丨" class="headerlink" title="丨10丨"></a>丨10丨</h2><font face="楷体">  我想，誓言之美，不在于它能对抗世事无常，而在于，今生今世，有那么一瞬间，我们曾经相信它能。<p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——《平生欢》 七堇年<br></font></p><p>  只是不想在遇见完美的你之前，用尽了完美的自己。</p><p>  最后只能是擦肩而过。</p><p>  害怕自己做出一个令自己抱憾终身的决定。</p><p>  害怕遇见了对的你却是在一个错误的时间。</p><p>  害怕到最后身边的人都早已不是身边的人。</p><p>  害怕在对的时间遇到了对的你，却不是你。</p><p>  或是用尽了最好的自己。</p><p>  不论是谁，不让自己后悔就好。</p><p>  2015年1月13日<br><br/></p><h2 id="丨11丨"><a href="#丨11丨" class="headerlink" title="丨11丨"></a>丨11丨</h2><p>  在浩瀚的星空中，我们独居于此。</p><p>  偶尔看到书上宇宙，太阳系，恰巧的公转周期和自转周期一样的月球。还有我们的地球。</p><p>  我总是会觉得自己好渺小，好渺小。</p><p>  甚至，令内心产生出一种迷茫。</p><p>  何去何从。<br><br/><br>  偶然夜里，或许是听歌时，或是仰天思考时，会突然引发一阵心悸，令我恐惧的心悸。</p><p>  不知我身体中的这份意识，最后，到哪儿去。</p><p>  在如此无际的世界之中，何处是起点，何处是尽头。</p><p>  有时想，安安心心过现在的生活就好。</p><p>  活得快乐，自在，获得自己想要的，去争取，至少不留遗憾。</p><p>  想着放手一搏，虽不知此后是什么。</p><p>  愿时间的尽头不会止步于此。</p><p>  2015年1月15日</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part.1 陪你直到 世界尽头</title>
      <link href="//5fb0/"/>
      <url>//5fb0/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-1-陪你直到-世界尽头"><a href="#Part-1-陪你直到-世界尽头" class="headerlink" title="Part.1 陪你直到 世界尽头"></a>Part.1 陪你直到 世界尽头</h2><font face="楷体"><p>  海明威说：“我多希望在我只爱他一个人时就死去。”</p><p>  但每个人一生都会遇到很多很多人，你爱的，你恨的，恨你的，爱你的。</p><p>  你会爱别人，你会恨自己。</p><p>  学会自己舔伤口，学会坚强地面对回忆。</p><p>  不要害怕未来，也不要奢求未来。</p><p>  不要怪罪过去，也不要沉迷过去。</p><p>  也许，并没有什么人在未来等你。</p><p>  但是，有我，一直，永远，和你一起。</p><p>  你加油。<br><br/><br>  你也加油。</p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——王若虚<br></font><br><br/></p><h2 id="丨1丨"><a href="#丨1丨" class="headerlink" title="丨1丨"></a>丨1丨</h2><p>  三月。</p><p>  路檐下莺飞草长，柳絮纷飞里看见了故乡。</p><p>  第一节的下课铃骤然回荡在耳边，然而讲台上的老师丝毫没有听见下课铃声的表现，口若悬河。</p><p>  向北边的窗户望去，教室里五十九个人散发出来的热量使冰冷的玻璃窗上结了一层雾气，白茫茫的，看不清外面的世界。</p><p>  走廊上传来隔壁班同学的惊呼，同桌w的思维波动骤然强烈了些许，嘀咕着：新同学，新同学…我带着上帝拯救世界的神情拍拍他的肩：“接受现实吧，我们班已经五十九个人了，再来一个就爆表了…”w侧过脸来，表示十分愤恨，是我将他从美好的幻想中拯救到现实世界。</p><p>  “平淡无奇的学习生活，总是需要一些激动人心的事物来增添色彩。”w念叨着。</p><p>  “想来个转到我们班的美女新同学直说就是的…”我翻着白眼。</p><p>  “而且，学习生涯又怎么会平淡无奇？”</p><p>  “下课。”惊呼。窗外鹅毛大雪。</p><p>  三月飞雪。</p><p>  2014年3月4日上午8:42.<br><br/><br>  趴在窗台上，看着纷纷扬扬飞落的雪花，喃喃道：“好冷。”</p><p>  是呀，好冷。</p><p>  雪花从苍白的天幕飞落，前仆后继，摩肩接踵，熙熙攘攘。</p><p>  落下，布满苍穹。</p><p>  2014年3月4日<br><br/></p><h2 id="丨2丨"><a href="#丨2丨" class="headerlink" title="丨2丨"></a>丨2丨</h2><p>  晚自修。</p><p>  在灯光下，鼻尖在纸上静静地上下左右，横竖撇捺。</p><p>  然后飞舞着的Gel Pen变成了一支2B铅笔，在空白的纸上缓缓挪动。</p><p>  画画真累啊。</p><p>  然后，然后一个短发女孩跃然纸上。</p><p>  我拿着给同桌w看。</p><p>  “嗯。”</p><p>  给她取个名字吧。</p><p>  “嗯？好，叫默默吧！”</p><p>  啊嘞？为啥？</p><p>  “因为，她沉默不语，不说话。”</p><p>  默默。</p><p>  3月6日<br><br/></p><h2 id="丨3丨"><a href="#丨3丨" class="headerlink" title="丨3丨"></a>丨3丨</h2><p>  一个月就这样过去了。</p><p>  转瞬即逝。</p><p>  但回想起来，的确是蛮充实的。<br><br/><br>  人是一种喜新厌旧的生物，但人也是怀旧的。</p><p>  果然，我如人人，人人如我，是矛盾的结合体。</p><p>  一天，心血来潮可以写下七个短篇，万字文章。</p><p>  但好像不疲乏。</p><p>  说到疲乏，一周下来，五天。</p><p>  做到一篇阅读理解，说一个女人，精力充沛，每天工作十二个小时。</p><p>  而我们，每天学习十二个小时零二十分钟，可是，我们精力充沛么？</p><p>  对，我们是祖国的花朵，健康，快乐，活蹦乱跳。</p><p>  最后，健康，快乐，活蹦乱跳。</p><p>  我们吃的是草，挤出来的是奶，血。</p><p>  我们每天辛勤工作，只睡七个小时。</p><p>  我们也会升职、加薪、当上总经理、出任CEO、走向人生巅峰。</p><p>  我真他喵的激动。<br><br/><br>  我愿面朝大海，春暖花开。</p><p>  幸福的人生，我来了。</p><p>  每天，都不留遗憾，画上一个完美的，句号。</p><p>  4月5日<br><br/></p><h2 id="丨4丨"><a href="#丨4丨" class="headerlink" title="丨4丨"></a>丨4丨</h2><p>  晚自修结束后，c要去寄信，</p><p>  我就和h一起回寝，h最近发粪图墙，力求逆袭。</p><p>  离熄灯还有六分钟的时候，</p><p>  我们关上了教室的灯，离开了教学楼。</p><p>  教学楼漆黑一片。<br><br/><br>  和老赵一同下楼。</p><p>  好像又看见了初中的影子，总是很迟才离开。</p><p>  下课铃，老师拖堂对我们来说并不重要。</p><p>  初中三年，我同老赵一同走过。</p><p>  再见，那些回不去的岁月。</p><p>  愿一切安好。<br><br/></p><h2 id="丨5丨"><a href="#丨5丨" class="headerlink" title="丨5丨"></a>丨5丨</h2><p>  中午，z去上厕所。</p><p>  稀里哗啦冲好厕所，z走了出来。</p><p>  h问了一句：“z，好吃么？”</p><p>  Z未接话，大声呸呸呸，然后就凑到水龙头上漱口。<br><br/><br>  果然不好吃啊…</p><p>  5月14日<br><br/></p><h2 id="丨6丨"><a href="#丨6丨" class="headerlink" title="丨6丨"></a>丨6丨</h2><p>  每天晚上寝室里开空调，都是被封建帝王通知的平民奋起的反抗。</p><p>  我们六人抵抗凡的专制统治。</p><p>  反抗将近一年，从未成功过。<br><br/><br>  晚上开空调，简直就是血泪史啊。</p><p>  凡的专制下，空调的开与关被严格掌控。</p><p>  偷走遥控器，偷走电池都挡不住凡的拉电闸。</p><p>  z生动地形容每天晚上开与不开空调之间的戏剧性。</p><p>  他说，这犹如一场大片。</p><p>  我们六人叫凡开空调，凡大喊：“雅蠛蝶，雅蠛蝶…”</p><p>  然后在众人软硬皆施，严刑逼供，众志成城之下。</p><p>  “嘟——”空调开了，凡大喊：“きもじ,きもじ…”  </p><p>  真实的故事。</p><p>  5月14日<br><br/></p><h2 id="丨7丨"><a href="#丨7丨" class="headerlink" title="丨7丨"></a>丨7丨</h2><p>  w在专心致志研究数学题。</p><p>  “哦，原来要这样设。”</p><p>  “难怪，果然是我设错了。”</p><p>  “我设是设出来了，但设错了。”</p><p>  “恩，要学习c的设法。”</p><p>  5月27日<br><br/></p><h2 id="丨8丨"><a href="#丨8丨" class="headerlink" title="丨8丨"></a>丨8丨</h2><p>  You come to love, not by finding the perfect person, </p><p>  but by seeing the imperfect person perfectly.</p><p>  5月27日<br><br/></p><h2 id="丨9丨"><a href="#丨9丨" class="headerlink" title="丨9丨"></a>丨9丨</h2><p>  今天和h、c出校门给小刚买生日礼物。</p><p>  唔，现在才知道，原来买女孩子饰品的店里可以买礼物。</p><p>  c轻车熟路地走进店中。</p><p>  我和h选好礼物，店员在帮忙包装。</p><p>  c在一旁愉快地翻弄女孩子的饰品，我和h在愉快地吹着电扇，</p><p>  店里没开空调，好热好热；</p><p>  看着c兴致勃勃，好冷好冷。</p><p>  5月28日<br><br/></p><h2 id="丨10丨"><a href="#丨10丨" class="headerlink" title="丨10丨"></a>丨10丨</h2><p>  “咱老班怎么就这么一套皮肤？”w侧头问我。</p><p>  什么？皮肤？</p><p>  “就他身上这套衣服，基本上没换过哎…”</p><p>  …</p><p>  “是不是劳动节限定皮肤，纪念版的？”</p><p>  …</p><p>  “劳动节活动送的，劳模，专属皮肤，文章之主。”</p><p>  VIP.</p><p>  “是不是他就这一套皮肤，还是同款好多件。”</p><p>  我怀疑他有一个这么大，我用手比划了一下：对，就这么大的衣柜。一打开全是这个衣服。</p><p>  “呵呵呵呵呵呵…”</p><p>  6月13日<br><br/></p><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>  半年就这样走过。</p><p>  点点滴滴在笔下成型，渐变永恒。</p><p>  要我从两个月前的心境来写下这篇跋，怕也是不可能的。</p><p>  虽说六十天的时光短暂，但不知为何，心中的思绪此起彼伏；时光在心中缓缓沉积，心境也缓缓变化。<br><br/><br>  感觉生变的一切都在昨日刚刚出现，无声无息。</p><p>  害怕在毫不知情之时，双眸短暂闭合之后，发现身边的一切都如同泡沫消散。物是人非。</p><p>  用高中第一任同桌z的那句话：时间真是捉弄人呀。<br><br/><br>  她是一个好女孩，他爱了她六个月，她也爱了他六个月。</p><p>  那年冬季，雪花纷飞，淡黄色的灯光将两人的身影拉得颇长。</p><p>  她张口，白雾从口中呼出，她不知自己是对是错。</p><p>  然而男孩拒绝了。</p><p>  灯光下，两人的身影静静相贴，而后分离，只有咫尺，却又如同相距千里。</p><p>  只是友情，无关爱情。<br><br/><br>  第二年春天。</p><p>  三月里，路檐下莺飞草长，柳絮纷飞里看见了故乡。</p><p>  三月飞雪。</p><p>  走廊里，无数人望着窗外的雪花惊叹，但还是终于将心中久久隐藏的情感流露出来，早在那日雪夜，心中，或许就早有波澜惊起。</p><p>  女孩心中的缝隙也在静静修补着，不着痕迹。</p><p>  有些事情静静地发生着，甜甜美美，让人沉溺其中，不愿自拔。</p><p>  种子，在土壤中，悄无声息地生根，发芽，也期望终有一日成为参天大树。</p><p>  我们总幻想着自己是生活的导演，觉得自己有改天换命之力，扭转乾坤，但，我们终究是演员，甚至连演员都不是，命运之力无形运转，引导着你走向远方或是心中，或者，不朽的永恒。</p><p>  我不愿写“这一天终于来到”。</p><p>  但是，我不能改写人生，</p><p>  女孩对男孩。</p><p>  从一开始就错了，她未勘透自己的内心。</p><p>  她对他，只有友情，无关爱情。</p><p>  终究只是三月飞雪。<br><br/><br>  时针，分针，秒针。</p><p>  马不停蹄地旋转着，相遇了，而又分开。</p><p>  男孩与女孩，他和她是真实的故事，在我身边，扣住心弦。</p><p>  我只愿我的一切如我所愿。</p><p>  这只是祈求，未来永远是未知数。</p><p>  就像阿甘所说的，生活就像巧克力，你永远不知道下一块会是什么。</p><p>  在夏日之中，就这样写上句号。</p><p>  2014年9月9日 22:00</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
